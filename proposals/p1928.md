# Arrays

<!--
Part of the Carbon Language project, under the Apache License v2.0 with LLVM
Exceptions. See /LICENSE for license information.
SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-->

[Pull request](https://github.com/carbon-language/carbon-lang/pull/1928)

<!-- toc -->

## Table of contents

-   [Problem](#problem)
-   [Background](#background)
-   [Proposal](#proposal)
-   [Details](#details)
-   [Rationale](#rationale)
-   [Alternatives considered](#alternatives-considered)

<!-- tocstop -->

## Problem

Arrays are base component of almost of programming languages. In the current
stage of Carbon development, arrays are missed.

## Background

An array is a set of scalar data placed in contiguous memory locations, all of
the same type and type parameters. The scalar data that make up an array are the
array elements which can be referenced by unique indexes.

A nested array is an array of arrays which may be non-continuous in memory.

A multidimensional array is an array with more than two dimensions which is
continuous in memory.

## Proposal

This proposal introduces array's internal representation, its declaration, and
indexing.

## Details

### Internal representation

For simplifying usage and raising safety of array's usage, internal representation
of arrays contains additional metadata:
```cpp
template <typename T, int32_t N> struct Array {
  std::array<int32_t, N> dimension_sizes;
  std::unique_ptr<T[]> data;
};
```
Here, `dimension_sizes` contains information about dimensions' length. `size()`
property of `dimension_sizes` contains information about number of dimensions.
`data` is continuous in memory place keeping scalar data.

This representation is closer to `std::array<T>` rather then `T[]`. Then,
interoperability between C++ and carbon is limited.

One-dimensional and nested arrays have `dimensions = 1`.

### Declaration

During declaration of arrays, it is more importantly to see type of variable.
It is the aim of the below presented alternatives of declaration.

Current realization (like in `Rust`):
```carbon
  var array_1D: [i32; 4];
  var array_2D: [i32; 4, 10]; // is not supported yet
  var array_nested: [[i32; 10]; 4];
```
In the case of nested array, definition of them a bit misunderstood due to
following indexing is inversed.

### Declaration like VLA

Also, it is possible to declare array in function with runtime defined size:
```carbon
  fn f(n: i32) -> i32 {
    var arr: [n; i32];
    return 0;
  }
```

Only if size is defined in compile-time and it is less than
`MAX_STACK_SIZE_ARRAY`, array is located in stack memory. Other definitions are
located in heap memory. It is especially important for the last example.

### Library API

For arrays that size is defined in compile-time, `StaticArray(T, shape)` is.
`shape` contains information for `dimension_sizes`.

If array size is not defined in compile-time or it should not be allocated in
stack, `BoxedArray(T, shape)`. Again, `shape` contains information for
`dimension_sizes`.

### Indexing

Indexing possible via integer values like in C style:
```carbon
  var array: [4; i32];
  var elem: auto = array[1];
```
and also via array:
```carbon
  var array_ind: [3; i32] = (0, 2, 4);
  var array1: [5; i32] = (4, 3, 2, 1, 0);
  var array2: auto = array[array_ind];
  // array2 == (array1[0], array1[2], array1[4]) == (4, 2, 0)
```
Array indexing is useful if slices generate arrays.

Indexes are also possible on left-side expression:
```carbon
  var array: [6; i32] = (5, 4, 3, 2, 1, 0);
  array[(0,1,2)] = array[(3,4,5)]; // array = (2, 1, 0, 2, 1, 0)
```
It requires the same sizes on the left and right sides.

at the same time, `array[(0,1)] = array[(1,0)]` will swap elements.

## Rationale

-   [Performance-critical software](/docs/project/goals.md#performance-critical-software)
    -   No need for a lower level language. Developers will use built-in arrays
        that know enough information itself.
-   [Software and language evolution](/docs/project/goals.md#software-and-language-evolution).

## Alternatives considered

This representation is closer to `std::array<T>` rather then `T[]`. As
extension of `std::array<T>`, it allows to have sizes not defined in
compile-time. Then, interoperability between C/C++ and Carbon is limited.

Alternatives for arrays' declaration:

Suggested in [#1787](https://github.com/carbon-language/carbon-lang/pull/1787):
```carbon
  var array_1D: [4; i32];
  var array_2D: [4, 10; i32];
  var array_nested: [4; [10; i32]];
```
This definition is deprived of a defect of previous definition, but the type is
the last one.

```carbon
  var array_1D: i32[4];
  var array_2D: i32[4, 10];
  var array_nested: i32[4][10];
```
This definition requires contextual information since `i32[4]` is the same as
`array_1D[1]` so it is necessary to separate type and variable.

`Go`-like syntax:
```carbon
  var array_1D: [4]i32;
  var array_2D: [4, 10]i32;
  var array_nested: [4][10]i32;
```
