# Arrays

<!--
Part of the Carbon Language project, under the Apache License v2.0 with LLVM
Exceptions. See /LICENSE for license information.
SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-->

[Pull request](https://github.com/carbon-language/carbon-lang/pull/1928)

<!-- toc -->

## Table of contents

-   [Problem](#problem)
-   [Background](#background)
-   [Proposal](#proposal)
-   [Details](#details)
-   [Rationale](#rationale)
-   [Alternatives considered](#alternatives-considered)

<!-- tocstop -->

## Problem

Arrays are base component of almost of programming languages. In the current
stage of Carbon development, arrays are missed.

## Background

An array is a set of scalar data placed in contiguous memory locations, all of
the same type and type parameters. The scalar data that make up an array are the
array elements which can be referenced by unique indexes.

A nested array is an array of arrays which may be non-continuous in memory.

A multidimensional array is an array with more than two dimensions which is
continuous in memory.

## Proposal

This proposal introduces array internal representation, its declaration, and
indexing.

## Details

### Internal representation

For simplifying usage and raising safety of array usage, internal representation
of arrays contains additional metadata:
```cpp
  struct {
    int32_t dimensions;
    int32_t * dimension_size;
    void * data;
  } Array;
```
Here, `dimensions` contains information about number of dimensions (necessary
for multidimensional arrays), `dimension_size` is an array of size `dimensions`
containing sizes for each dimensions, and `data` is continuous in memory place
keeping scalar data.

This representation is closer to `std::vector<T>` rather then `T[]`. Then,
interoperability between C++ and carbon is limited.

One-dimensional and nested arrays have `dimensions = 1`.

### Declaration

During declaration of arrays, it is more importantly to see type of variable.
It is the aim of the below presented alternatives of declaration.

Current realization:
```carbon
  var array_1D: [i32; 4];
  var array_2D: [i32; 4, 10]; // is not supported yet
  var array_nested: [[i32; 10]; 4];
```
In the case of nested array, definition of them a bit misunderstood due to
following indexing is inversed.

Suggested in [#1787](https://github.com/carbon-language/carbon-lang/pull/1787):
```carbon
  var array_1D: [4; i32];
  var array_2D: [4, 10; i32];
  var array_nested: [4; [10; i32]];
```
This definition is deprived of a defect of previous definition, but the type is
the last one.

Alternatives:
```carbon
  var array_1D[4]: i32;
  var array_2D[4, 10]: i32;
  var array_nested[4][10]: i32;
```
In this alternative, `auto` will work only for types, not for dimensions of
array.

```carbon
  var array_1D: i32[4];
  var array_2D: i32[4, 10];
  var array_nested: i32[4][10];
```
This definition requires contextual information since `i32[4]` is the same as
`array_1D[1]` so it is necessary to separate type and variable.

Also, it is possible to declare array in function with runtime defined size:
```carbon
  fn f(n: i32) -> i32 {
    var arr: [n; i32];
    return 0;
  }
```

Only of size is defined in compile-time and it is less than
`MAX_STACK_SIZE_ARRAY`, array is located in stack memory. Other definitions are
located in heap memory. It is especially important for the last example.

### Indexing

Indexing possible via integer values like in C style:
```carbon
  var array: [4; i32];
  var elem: auto = array[1];
```
and also via array:
```carbon
  var array_ind: [3; i32] = (0, 2, 4);
  var array: [5; i32] = (4, 3, 2, 1, 0);
  var arrav: auto = array[array_ind];
  // arrav == (array[0], array[2], array[4]) == (4, 2, 0)
```
Array indexing is useful if slices generate arrays.

Indexes are also possible on left-side expression:
```carbon
  var array: [6; i32] = (5, 4, 3, 2, 1, 0);
  array[(0,1,2)] = array[(3,4,5)]; // array = (2, 1, 0, 2, 1, 0)
```
It requires the same sizes on the left and right sides.

## Rationale

This proposal mostly has effect on [Software and language evolution](/docs/project/goals.md#software-and-language-evolution).

With array indexing, slices and vector operations it is possible to rewrite the
following code (note, here, the first index of array is `1`):
```fortran
    do i = 1, npoints
      rhosum(i) = rho(i * 2 - 1) + rho(i * 2)
    end do
```
as
```fortran
    rhosum(1:npoints) = rho(1:2*npoints:2) + rho(2:2*npoints:2)
```

## Alternatives considered

This presented representation is closer to `std::vector<T>` rather then `T[]`.
Then, interoperability between C/C++ and Carbon is limited. So, alternatively,
we may use C/C++ style arrays.
